-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Haskell Simple Structured Query Language
--   
--   Please see the README on GitHub at
--   <a>https://github.com/shraiysh/hasql#readme</a>
@package HaSSQL
@version 1.0.0


module Funcs

-- | The <a>regularParse</a> parses a expression regularlly
regularParse :: Parser a -> String -> Either ParseError a

-- | The <a>parseWithEof</a> is a wrapper that throws error if you havenâ€™t
--   consumed all the input
parseWithEof :: Parser a -> String -> Either ParseError a

-- | The <a>parseWithLeftOver</a> is wrapper that tell you what was not
--   consumed from the input by input parser
parseWithLeftOver :: Parser a -> String -> Either ParseError (a, String)

-- | The <a>parseWithWSEof</a> wrapper allows parsing when input constains
--   and leading whitespaces
parseWithWSEof :: Parser a -> String -> Either ParseError a

-- | The <a>lexeme</a> is wrapper parser that eats up any following
--   whitespaces after parsing.
lexeme :: Parser a -> Parser a

-- | The <a>integer</a> parses a integer constant
integer :: Parser Integer

-- | The <a>identifier</a> parses a identifier string
identifier :: Parser String

-- | The <a>symbol</a> parses a single character symbol or operator It
--   takes string as arguments and comapres it with parsed string.
symbol :: String -> Parser String

-- | The <a>comma</a> parses comma
comma :: Parser Char

-- | The <a>openParen</a> parses Opening paranthesis
openParen :: Parser Char

-- | The <a>closeParen</a> parses closing paranthesis
closeParen :: Parser Char

-- | The <tt>keyowrd</tt> parses a occurence of string given as input It
--   takes a string to pe parsed as only input
keyword :: String -> Parser String

-- | The <a>parens</a> function parses anything between opening and closing
--   paranthesis
parens :: Parser a -> Parser a

-- | The <a>identifierBlacklist</a> parses only that identifiers that are
--   not in blacklist It takes a blacklist of type List as an argument
identifierBlacklist :: [String] -> Parser String

-- | The <a>whitespace</a> parses any number of any type of whiespaces
whitespace :: Parser ()

-- | The <a>keyword_</a> parses keywords and ignores them
keyword_ :: String -> Parser ()

-- | The <a>symbol_</a> parses symbol and ignores them
symbol_ :: String -> Parser ()

-- | The <a>commaSep1</a> parses comma seperated items and returns a list
commaSep1 :: Parser a -> Parser [a]

-- | The <a>stringToken</a> parses a string literal in single quotes
stringToken :: Parser String

-- | The <a>boolToken</a> parses boolean constants <a>True</a> and
--   <a>False</a>
boolToken :: Parser Bool


module ExpressionParser

-- | <a>ValueExpr</a> represnts a expression
data ValueExpr

-- | <a>NumLit</a> type constructor for integer constants that takes
--   integer as argument
NumLit :: Integer -> ValueExpr

-- | <a>Iden</a> type constructor for identifier that takes string as
--   argument
Iden :: String -> ValueExpr

-- | <a>PrefOp</a> for prefix operators that takes operator(String) and a
--   <a>ValueExpr</a>
PrefOp :: String -> ValueExpr -> ValueExpr

-- | <a>BinOp</a> for binary operators that takes operator(String) and two
--   <a>ValueExpr</a>
BinOp :: ValueExpr -> String -> ValueExpr -> ValueExpr

-- | <a>Parens</a> type constructor that <a>ValueExpr</a> as argument that
--   is ought to be in parenthesis.
Parens :: ValueExpr -> ValueExpr

-- | <a>StringLit</a> type constructor for string literals that takes
--   string as argument
StringLit :: String -> ValueExpr

-- | <a>Star</a> for * symbol
Star :: ValueExpr

-- | <a>BoolLit</a> type constructor for boolean constants that takes bool
--   as argument
BoolLit :: Bool -> ValueExpr

-- | <a>EvalType</a> represnts a return type of evaluator
data EvalType

-- | <a>EvalType</a> holds am integral return type
Int :: Integer -> EvalType

-- | <a>Boolean</a> holds a boolean return type
Boolean :: Bool -> EvalType

-- | <a>Error</a> holds a error string
Error :: String -> EvalType

-- | <a>num</a> wraps a parsed integer literal in <a>ValueExpr</a> datatype
num :: Parser ValueExpr

-- | <a>iden</a> wraps a parsed identifier literal in <a>ValueExpr</a>
--   datatype Argument is a blacklist
iden :: [String] -> Parser ValueExpr

-- | <tt>bolean</tt> wraps a parsed boolean literal in <a>ValueExpr</a>
--   datatype
boolean :: Parser ValueExpr

-- | <a>parensValue</a> wraps a parsed parenthesis expression in
--   <a>ValueExpr</a> datatype
parensValue :: Parser ValueExpr

-- | <a>term</a> contains all possible expression types
term :: [String] -> Parser ValueExpr

-- | <a>table</a> contains precedence, associativity of integer and boolean
--   operators
table :: [[Operator Char () ValueExpr]]

-- | <a>valueExpr</a> parses a given string to <a>ValueExpr</a> datatype
--   Input is a blacklist
valueExpr :: [String] -> Parser ValueExpr

-- | <a>stringLit</a> wraps a parsed string literal in <a>ValueExpr</a>
--   datatype
stringLit :: Parser ValueExpr

-- | <a>star</a> wraps a parsed <a>*</a> keyword in <a>ValueExpr</a>
--   datatype
star :: Parser ValueExpr

-- | <a>evaluate</a> evaluates a parsed <a>ValueExpr</a> to integer
--   <a>EvalType</a> if possible otherwise Exception First argument is map
--   of variables and corresponding values. Second argument is a parsed
--   expression type.
evaluate :: Map String ValueExpr -> Either ParseError ValueExpr -> EvalType

-- | <a>evaluate2</a> evaluates a parsed <a>ValueExpr</a> to boolean
--   <a>EvalType</a>if possible otherwise Exception First argument is map
--   of variables and corresponding values. Second argument is a parsed
--   expression type.
evaluate2 :: Map String ValueExpr -> Either ParseError ValueExpr -> EvalType

-- | <a>evaluateExpr</a> evaluates a <a>ValueExpr</a> to Integer if
--   possible otherwise Exception First argument is map of variables and
--   corresponding values. Second argument is a parsed expression
--   (<a>ValueExpr</a>) type.
evaluateExpr :: Map String ValueExpr -> ValueExpr -> Integer

-- | <a>evaluateExpr2</a> evaluates a <a>ValueExpr</a> to Bool if possible
--   otherwise Exception First argument is map of variables and
--   corresponding values. Second argument is a parsed expression
--   (<a>ValueExpr</a>) type.
evaluateExpr2 :: Map String ValueExpr -> ValueExpr -> Bool
instance GHC.Show.Show ExpressionParser.EvalType
instance GHC.Classes.Eq ExpressionParser.EvalType
instance GHC.Show.Show ExpressionParser.ValueExpr
instance GHC.Classes.Eq ExpressionParser.ValueExpr


module Database

-- | <a>sampleCommands</a> is for debugging purposes.
sampleCommands :: IO Integer

-- | <a>Column</a> stores a column in a table as a list of its values along
--   with the datatype and name of column
data Column
Column :: String -> Datatype -> [String] -> Column
[cName] :: Column -> String
[cDatatype] :: Column -> Datatype
[cValues] :: Column -> [String]

-- | <a>newColumn</a> Returns new column (Maybe Column) First argument is
--   name of column Second argument is datatype Third argument is list of
--   values
newColumn :: String -> Datatype -> [String] -> Maybe Column

-- | <a>Table</a> stores a map of columns (key is column Name) with table
--   name and list of names of columns
data Table
Table :: String -> [String] -> Map String Column -> [Int] -> Table
[tName] :: Table -> String
[tColNameList] :: Table -> [String]
[tColumns] :: Table -> Map String Column
[tPKeys] :: Table -> [Int]

-- | <a>newTable</a> returns new table (Maybe Table) First argument is
--   table name Second argument is (list of colNames, Map of those colnames
--   -&gt; Columns)
newTable :: String -> ([String], Map String Column) -> [Int] -> Maybe Table

-- | <a>Database</a> stores a database with a name and map of tables
--   indexed by their names
data Database
Database :: String -> Map String Table -> Database
[dName] :: Database -> String
[dTables] :: Database -> Map String Table

-- | <a>newDatabase</a> returns new database (Maybe Database) First
--   argument is datbase name Second argument map of tables indexed by
--   their names
newDatabase :: String -> Map String Table -> Maybe Database

-- | <a>Datatype</a> is for datatype in a column
data Datatype
INT :: Datatype
STRING :: Datatype
BOOL :: Datatype

-- | <a>containsTable</a> is True if database contains table, o/w False
--   First argument is tableName Second argument is database object (Maybe
--   database)
containsTable :: String -> Maybe Database -> Bool

-- | <a>containsColumn</a> returns True if table within database contains a
--   column, o/w false First argument is column name Second argument is
--   database (Maybe Database) Third argument is table name
containsColumn :: String -> Maybe Database -> String -> Bool

-- | <a>getTable</a> returns table from database (Maybe Table) First
--   argument is table name Second argument is database (Maybe Database)
getTable :: String -> Maybe Database -> Maybe Table

-- | <a>count</a> returns the number of entries in a table First argument
--   is table (Maybe Table)
count :: Maybe Table -> Int

-- | <a>getColumn</a> returns column in specific table of a database (Maybe
--   Column) First argument is name of column (String) Second argument is
--   table (Maybe Table)
getColumn :: String -> Maybe Table -> Maybe Column

-- | <a>addNewTable</a> adds an empty table to database and returns new
--   database (Maybe Database) First argument is tableName (String) Second
--   argument is database (Maybe Database)
addNewTable :: String -> Maybe Database -> Maybe Database

-- | <a>addColumnToTable</a> adds a column to a table and returns new table
--   (Table) First argument is column name (String) Second argument is
--   column datatype (Datatype) Third argumenr is old table (Table)
addColumnToTable :: String -> Datatype -> Table -> Table

-- | <a>addColumn</a> adds a column to specific table in database and
--   returns new database (Maybe Database) First argument is column name
--   (String) Second argumenr is column datatype (Datatype) Third argumenr
--   is database (Maybe Database) Fourth argumenr is table name (String)
addColumn :: String -> Datatype -> Maybe Database -> String -> Maybe Database

-- | <a>insertOne</a> inserts one entry in one column of one table in a
--   database First argument is value (String) Second argument is it's
--   datatype (Datatype) Third argument is old database (Maybe Database)
--   Fourth argument is table name (String) Fifth argumenr is column name
--   (String)
insertOne :: String -> Datatype -> Maybe Database -> String -> String -> Maybe Database

-- | <a>isValidDatatype</a> checks if datatypes corresponding to column
--   names list are in sync with the table in database or not. Returns true
--   if they both conform First argumenr is table (Maybe Table) Second
--   argument is list of column names [String] Third argument is list of
--   datatypes [Datatype]
isValidDatatype :: Maybe Table -> [String] -> [Datatype] -> Bool

-- | <a>addPrimaryKeyToTable</a> adds one primary key to a table First
--   argument is a table (Table)
addPrimaryKeyToTable :: Table -> Table

-- | <a>addPrimaryKey</a> adds one primary key to table in database First
--   argument is database (Maybe Database) Second argument is table name
--   (String)
addPrimaryKey :: Maybe Database -> String -> Maybe Database

-- | <a>insert</a> inserts an entry (row) in database -&gt; table and
--   returns new database First argumenr is list of colNames [String]
--   Second argument is corresponding list of values [String] Third
--   argumenr is corresponding list of datatypes [Datatype] Fourth argument
--   old database (Maybe Database) Fifth argument is table name (String)
insert :: [String] -> [String] -> [Datatype] -> Maybe Database -> String -> Maybe Database

-- | <a>insertDefault</a> inserts an entry in the default column order.
--   This does not check for datatype as of now. First argument is list of
--   values Second argument is old database Third argument is tableName
insertDefault :: [String] -> Maybe Database -> String -> Maybe Database

-- | <a>getColList</a> is a Utility function for find*
getColList :: String -> Maybe Database -> [Column]

-- | <a>findEntryAtIndex</a> finds entry at index in table and returns as
--   [tuples] where tuple = (col name, col type, col value) First argument
--   is tableName Second argument is database Third argument is index
findEntryAtIndex :: String -> Maybe Database -> Int -> [(Int, String, Datatype, String)]

-- | <a>litValue</a> is a utility function to support evaluation of
--   ValueExpr on columns (which are stored as String)
litValue :: String -> Datatype -> ValueExpr

-- | <a>find</a> finds all entries in (db -&gt; table) with value, datype
--   and returns as [entries] where entry=[tuples] where tuple = (col name,
--   col type, col value) First argument is value (Right) ValueExpr that
--   evaluates to true or false Second argument is database (Maybe
--   Database) Third argument is table name
find :: Either ParseError ValueExpr -> Maybe Database -> String -> [[(Int, String, Datatype, String)]]

-- | <a>deleteFromList</a> is a utility function to delete an entry from a
--   list
deleteFromList :: Int -> [a] -> [a]

-- | <a>deleteEntryAtIndex</a> deletes an entry from the table First
--   argument is the index in table for the entry to be deleted Second
--   argument is the database (Maybe Database) Third argument is table name
deleteEntryAtIndex :: Int -> Maybe Database -> String -> Maybe Database

-- | <a>deleteEntryAtIndices</a> is used to delete multiple entries from a
--   specific table of a database First argument is list of indices [Int]
--   Second argument is database (Maybe Database) Third argumenr is table
--   name (String)
deleteEntryAtIndices :: [Int] -> Maybe Database -> String -> Maybe Database

-- | <a>delete</a> deletes all entries that follow a specific condition
--   from a table First argument is condition Second argument is Maybe
--   Database Third argument is table name (String)
delete :: Either ParseError ValueExpr -> Maybe Database -> String -> Maybe Database

-- | <a>orderBy</a> orders the entries given by find based on the value
--   given by expression First argument is the expression that gives the
--   deciding value Second argument is the entrylist returned by find /
--   select
orderBy :: Either ParseError ValueExpr -> [[(Int, String, Datatype, String)]] -> [[(Int, String, Datatype, String)]]

-- | <a>select</a> selects specific columns from the output of find/orderBy
--   and returns list of entries with those columns only First argument is
--   column alias (if new name of the columns is needed, then this is
--   used). If this is empty, all columns with default names are returned
--   Second argument is output of find/orderBy
select :: [(String, String)] -> [[(Int, String, Datatype, String)]] -> [[(Int, String, Datatype, String)]]
instance GHC.Classes.Eq Database.Database
instance GHC.Show.Show Database.Database
instance GHC.Classes.Eq Database.Table
instance GHC.Show.Show Database.Table
instance GHC.Classes.Eq Database.Column
instance GHC.Show.Show Database.Column
instance GHC.Classes.Eq Database.Datatype
instance GHC.Show.Show Database.Datatype


module DeleteParser

-- | <a>DeleteExpr</a> is a constructor type for Delete Queries.
data DeleteExpr
Delete :: ValueExpr -> ValueExpr -> DeleteExpr

-- | <tt>iTname</tt> is name of the table
[dTname] :: DeleteExpr -> ValueExpr

-- | <tt>iWhere</tt> contains where clause expression
[dWhere] :: DeleteExpr -> ValueExpr

-- | deleteExpr' aggerates all parsers to parse CREATE query
deleteExpr :: Parser DeleteExpr

-- | <a>makeDelete</a> creates empty <a>DeleteExpr</a> object
makeDelete :: DeleteExpr

-- | <a>evaluateDelete</a> evaluates parsed <a>DeleteExpr</a> to delete
--   rows in database table First argument is parsed <a>DeleteExpr</a>
--   Second argument is databse instance
evaluateDelete :: Either ParseError DeleteExpr -> Maybe Database -> Maybe Database
instance GHC.Show.Show DeleteParser.DeleteExpr
instance GHC.Classes.Eq DeleteParser.DeleteExpr


module CreateParser

-- | <a>CreateExpr</a> is a constructor for Create Queries
data CreateExpr
Create :: ValueExpr -> [(ValueExpr, Datatype)] -> CreateExpr

-- | <a>iTname</a> is name of the table
[iTname] :: CreateExpr -> ValueExpr

-- | <a>iColLists</a> contains list of column names and their dataype
--   values
[iColLists] :: CreateExpr -> [(ValueExpr, Datatype)]

-- | <a>createExpr</a> aggerates all parsers to parse CREATE query
createExpr :: Parser CreateExpr

-- | <a>makeCreate</a> creates empty <a>CreateExpr</a> object
makeCreate :: CreateExpr

-- | <a>evaluateCreate</a> evaluates parsed <a>CreateExpr</a> to create a
--   new table and add columns to it. First argument is parsed
--   <a>CreateExpr</a> Second argument is databse instance
evaluateCreate :: Either ParseError CreateExpr -> Maybe Database -> Maybe Database
instance GHC.Show.Show CreateParser.CreateExpr
instance GHC.Classes.Eq CreateParser.CreateExpr


module InsertParser

-- | <a>InsertExpr</a> is a constructor type for Insert Queries
data InsertExpr
Insert :: ValueExpr -> [ValueExpr] -> [ValueExpr] -> InsertExpr

-- | <tt>iTname</tt> is name of the table
[iTable] :: InsertExpr -> ValueExpr

-- | <a>iColumns</a> are name of columns
[iColumns] :: InsertExpr -> [ValueExpr]

-- | <a>iValues</a> are values to insert (NumLit, StringLit, BoolLit)
[iValues] :: InsertExpr -> [ValueExpr]

-- | <a>insertExpr</a> aggerates all parsers to parse INSERT query
insertExpr :: Parser InsertExpr

-- | <a>makeInsert</a> creates empty <a>InsertExpr</a> object
makeInsert :: InsertExpr

-- | <a>evaluateInsert</a> evaluates insert expression ans insert values to
--   table First argument is InserExpr Second argument is database instance
evaluateInsert :: Either ParseError InsertExpr -> Maybe Database -> Maybe Database
instance GHC.Show.Show InsertParser.InsertExpr
instance GHC.Classes.Eq InsertParser.InsertExpr


module QueryParser

-- | <a>QueryExpr</a> represents a SELECT statement
data QueryExpr
Select :: [(ValueExpr, Maybe String)] -> ValueExpr -> Maybe ValueExpr -> [ValueExpr] -> Maybe ValueExpr -> [ValueExpr] -> QueryExpr

-- | <a>qeSelectList</a> contains list of selected columns
[qeSelectList] :: QueryExpr -> [(ValueExpr, Maybe String)]

-- | <tt>qeFromClause</tt> contains table name
[qefromClause] :: QueryExpr -> ValueExpr

-- | <a>qeWhere</a> contains where clause expression
[qeWhere] :: QueryExpr -> Maybe ValueExpr

-- | <a>qeGroupBy</a> contains list of groupby expresions
[qeGroupBy] :: QueryExpr -> [ValueExpr]

-- | <a>qeHaving</a> contains havingby expression
[qeHaving] :: QueryExpr -> Maybe ValueExpr

-- | <a>qeOrderBy</a> contains list of orderby clause expressions
[qeOrderBy] :: QueryExpr -> [ValueExpr]

-- | <a>queryExpr</a> aggregates all parsers to parse a SELECT statement
queryExpr :: Parser QueryExpr

-- | <a>makeSelect</a> makes a empty <a>QueryExpr</a> object
makeSelect :: QueryExpr

-- | <a>evaluateQuery</a> evaluates a query expression First argument is
--   parsed query expression Second argument is Maybe Database instance
evaluateQuery :: Either ParseError QueryExpr -> Maybe Database -> [[(Int, String, Datatype, String)]]
instance GHC.Show.Show QueryParser.QueryExpr
instance GHC.Classes.Eq QueryParser.QueryExpr


module SQLParser

-- | <a>SQLExpr</a> is a wrapping type constructor for Select, Insert and
--   Delete statements. 'SELECT QueryExpr' contains
data SQLExpr

-- | Parses a SELECT query
SELECT :: QueryExpr -> SQLExpr

-- | Parses a INSERT Query
INSERT :: InsertExpr -> SQLExpr

-- | Parses a CREATE Query
CREATE :: CreateExpr -> SQLExpr

-- | Parses a DELETE Query
DELETE :: DeleteExpr -> SQLExpr

-- | <a>ResType</a> is a wrapping type constructor for the response types
--   of each of the above statements.
data ResType

-- | Database instance for insert, create and delete queries
DB :: Maybe Database -> ResType

-- | Return object for SELECT queries
OUT :: [[(Int, String, Datatype, String)]] -> ResType
ERROR :: String -> ResType

-- | <a>sqlExpr</a> describes an SQL expression.
sqlExpr :: Parser SQLExpr

-- | <a>evaluateSQL</a> evaluates each Expression using individual case
--   statements
evaluateSQL :: Either ParseError SQLExpr -> ResType -> ResType

-- | <tt>getHeader</tt> returns string of headers of table First argument
--   is list of headers
getHeaders :: [(Int, String, Datatype, String)] -> String

-- | <tt>getHeader</tt> returns string of depicting one entire row First
--   argument is a row
getRow :: [(Int, String, Datatype, String)] -> String

-- | <a>getRows</a> prints the rows which are the output of select query
--   The argument is output of select parsed query
getRows :: [[(Int, String, Datatype, String)]] -> IO ()

-- | <a>queryPrinter</a> prints the Select query output in a tabular
--   fashion The argument is output of select parsed query
queryPrinter :: ResType -> IO ()
instance GHC.Show.Show SQLParser.ResType
instance GHC.Classes.Eq SQLParser.ResType
instance GHC.Show.Show SQLParser.SQLExpr
instance GHC.Classes.Eq SQLParser.SQLExpr
